---
title: "Density Estimation in mlr3proba"
author: "Nurul Ain Toha"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Density Estimation in mlr3proba}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>"
)
set.seed(1)
lgr::get_logger("mlr3")$set_threshold("error")
```

This vignette is an introduction to performing survival analysis in **mlr3proba**.

## A very quick introduction to density estimation

Density estimation is the learning task to find the unknown distribution from which an i.i.d. data set is generated. We interpret this broadly, with this distribution not necessarily being continuous (so may possess a mass not density). The conditional case, where a distribution is predicted conditional on covariates, is known as ‘probabilistic supervised regression’, and will be implemented in mlr3proba in the near-future. In mlr3proba, (unconditional) density estimation is viewed as an unsupervised task, whereas probabilistic supervised regression (or conditional density estimation) is a supervised task

## Density Task

We consider density estimation as an unsupervised method. Therefore, `TaskDens` is an unsupervised task unlike 'TaskClassif' and `TaskRegr`. Therefore, 'TaskDens' inherits directly from 'Task'. There are two things that should be not misunderstood from `TaskRegr` and `TaskCalssif`: 

* `$target` - the variable to estimate density

* `$truth` - the target column to be estimated and NOT the true density since it is unknown


```{r}
library(mlr3proba); library(mlr3)

TaskDens$new(id = "mpg", backend = datasets::mtcars, target = "mpg" )

task = TaskDens$new(id = "mpg", backend = datasets::mtcars, target = "mpg" )

task

task$truth()[1:10]

```

## Train and Predict
Although `TaskDens` is unsupervised, it still has `train` and `predict` methods. The 'train' method creates a 'distr6' object   which contains `pdf` (some learners will have `cdf` and `quantile`). The 'predict' method evaluates the 'pdf' (and 'cdf' if available). 

```{r}

# create task and learner

task_faithful = TaskDens$new(id = "eruptions", backend = datasets::faithful, target = "eruption")
learner = lrn("dens.kde")

# train/test split 

train_set = sample(task_cars$nrow, 0.8 * task_faithful$nrow)
test_set = setdiff(seq_len(task_faithful$nrow), train_set)

# fitting KDE and model inspection

learner$train(task_cars, row_ids = train_set)
learner$model
class(learner$model)

# make predictions for new data

prediction = learner$predict(task_faithful, row_ids = test_set)
prediction
```

## Estimate - pdf, cdf

Every `PredictionDens` object can predict:

* `pdf` - point probability density estimation.

Some learners can predict: 

* `cdf` - the cumulative density function

Some model can output:

* `quantile `- where the output is a random variable when taking probability as the input

```{r}

# An example of learner that can predict is `dens.spline`

task_boston = TaskDens$new(id = "lstat", backend = MASS::Boston, target = "lstat")
learner = lrn("dens.spline")

train_set = sample(task_boston$nrow, 0.8 * task_boston$nrow)
test_set = setdiff(seq_len(task_boston$nrow), train_set)

learner$train(task_boston, row_ids = train_set)
prediction = learner$predict(task_boston, row_ids = test_set)
prediction

# An example of learner where the model can output quantile 

# In the previous example, `dens.spline` learner can output the quantile 

learner$model$quantile(0.1)

# `pdf` is evaluated using the `log-loss`

prediction$score()

```




