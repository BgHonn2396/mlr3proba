---
title: "Density Estimation in mlr3proba"
author: "Nurul Ain Toha"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Density Estimation in mlr3proba}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>"
)
set.seed(1)
lgr::get_logger("mlr3")$set_threshold("error")
```

This vignette is an introduction to performing survival analysis in **mlr3proba**.

## A very quick introduction to survival analysis

Survival analysis is a sub-field of supervised machine learning in which the aim is to predict
the survival distribution of a given individual. Arguably the main feature of survival analysis is
that unlike classification and regression, learners are trained on two features: 1. the time until the 
event takes place, 2. the event type: either censoring or death. At a particular time-point,
an individual is either: alive, dead, or censored. Censoring occurs if it is unknown if an individual is
alive or dead. For example, say we are interested in patients in hospital and every day it is recorded
if they are alive or dead, then after a patient leaves it is unknown if they are alive or dead, hence
they are censored.

In the case that there is no censoring, but a predicted probability distribution is still the goal,
then probabilistic regression learners are advised instead.

## Survival Tasks

Unlike `TaskClassif` and `TaskRegr` which have a single 'target' argument, `TaskSurv` mimics the
`survival::Surv` object and has three-four target arguments (dependent on censoring type)

```{r}
library(mlr3proba); library(mlr3); library(survival)

# type = "right" is default

TaskSurv$new(id = "right_censored", backend = survival::rats,
             time = "time", event = "status", type = "right")

task = TaskSurv$new(id = "interval_censored", backend = survival::bladder2[,-c(1, 7)],
                    time = "start", time2 = "stop", type = "interval2")
task
task$truth()[1:10]
```

## Train and Predict

```{r}

# create task and learner

veteran = mlr3misc::load_dataset("veteran", package = "survival")
task_veteran = TaskSurv$new(id = "veteran", backend = veteran, time = "time", event = "status")
learner = lrn("surv.coxph")

# train/test split 

train_set = sample(task_veteran$nrow, 0.8 * task_veteran$nrow)
test_set = setdiff(seq_len(task_veteran$nrow), train_set)

# fit Cox PH and inspect model

learner$train(task_veteran, row_ids = train_set)
learner$model

# make predictions for new data

prediction = learner$predict(task_veteran, row_ids = test_set)
prediction
```

## Evaluate - crank, lp, and distr

Every `PredictionSurv` object can predict one or more of:

* `lp` - Linear predictor calculated as the fitted coefficients multiplied by the test data.
* `distr` - Predicted survival distribution, either discrete or continuous. Implemented in **[distr6](https://CRAN.R-project.org/package=distr6)**.
* `crank` - Continuous risk ranking.

`lp` and `crank` can be used with measures of discrimination such as the concordance index. Whilst
`lp` is a specific mathematical prediction, `crank` is any continuous ranking that identifies who is
more or less likely to experience the event. So far the only implemented learner that only returns a continuous
ranking is `surv.svm`. If a `PredictionSurv` returns an `lp` then the `crank` is identical to this.
Otherwise `crank` is calculated as the expectation of the predicted survival distribution. Note that 
for linear proportional hazards models, the ranking (but not necessarily the `crank` score itself)
given by `lp` and the expectation of `distr`, is identical.

```{r}
# In the previous example, Cox model predicts `lp` so `crank` is identical

all(prediction$lp == prediction$crank)
prediction$lp[1:10]

# These are evaluated with measures of discrimination and calibration.
# As all PredictionSurv objects will return crank, Harrell's C is the default measure.

prediction$score()

# distr is evaluated with probabilistic scoring rules.

measure = lapply(c("surv.graf", "surv.grafSE"), msr)
prediction$score(measure)

# Often measures can be integrated over mutliple time-points, or return
# predictions for single time-points

measure = msr("surv.graf", times = 60)
prediction$score(measure)
```

### Probability distributions with distr6

Predicted distributions are implemented in **[distr6](https://CRAN.R-project.org/package=distr6)**, which
contains functionality for plotting and further analysis of probability distributions. See [here](https://alan-turing-institute.github.io/distr6/) for full tutorials. Briefly we will go over the most important parts for **mlr3proba**.

```{r, message=FALSE}
task = tgen("simdens")$generate(20)
learner = lrn("dens.logspline")
learner$train(task)

# The fitted model is a distr6 Distribution
learner$model

# This contains useful properties and methods
x = seq.int(0,1,length.out = 10)
learner$model$pdf(x)
learner$model$cdf(x)
learner$model$quantile(0.42)
learner$model$rand(5)

# decorators impute numerical results
distr6::decorate(learner$model, "CoreStatistics")
summary(learner$model)

# Plotting is also available
plot(learner$model)
```


